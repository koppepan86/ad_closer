<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>パフォーマンス最適化テスト</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .test-section h3 {
            margin-top: 0;
            color: #333;
        }
        
        .controls {
            margin: 10px 0;
        }
        
        .controls button {
            margin: 5px;
            padding: 8px 16px;
            background: #007cba;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .controls button:hover {
            background: #005a87;
        }
        
        .controls button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .stats-display {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
        }
        
        .loading-indicator {
            display: none;
            padding: 10px;
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .loading-indicator.active {
            display: block;
        }
        
        .test-elements {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .test-element {
            height: 150px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            position: relative;
        }
        
        .test-element.large {
            height: 300px;
            background: linear-gradient(45deg, #667eea, #764ba2);
        }
        
        .test-element.small {
            height: 100px;
            background: linear-gradient(45deg, #f093fb, #f5576c);
        }
        
        .performance-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .performance-good {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .memory-usage {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .memory-bar {
            flex: 1;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            margin: 0 10px;
            overflow: hidden;
        }
        
        .memory-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #ff9800, #f44336);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>AdPreviewCapture パフォーマンス最適化テスト</h1>
        
        <div class="test-section">
            <h3>1. 500ms以内処理完了テスト</h3>
            <div class="controls">
                <button onclick="testProcessingTime()">処理時間テスト実行</button>
                <button onclick="testBatchProcessing()">バッチ処理テスト</button>
                <button onclick="testLargeElementProcessing()">大量要素処理テスト</button>
            </div>
            <div id="processing-time-results" class="stats-display"></div>
        </div>
        
        <div class="test-section">
            <h3>2. メモリ使用量監視・自動クリーンアップテスト</h3>
            <div class="controls">
                <button onclick="testMemoryMonitoring()">メモリ監視開始</button>
                <button onclick="triggerMemoryCleanup()">手動クリーンアップ</button>
                <button onclick="simulateMemoryPressure()">メモリ圧迫シミュレート</button>
            </div>
            <div class="memory-usage">
                <span>メモリ使用量:</span>
                <div class="memory-bar">
                    <div id="memory-fill" class="memory-fill" style="width: 0%"></div>
                </div>
                <span id="memory-text">0 MB</span>
            </div>
            <div id="memory-results" class="stats-display"></div>
        </div>
        
        <div class="test-section">
            <h3>3. 遅延読み込み機能テスト</h3>
            <div class="controls">
                <button onclick="testLazyLoading()">遅延読み込みテスト</button>
                <button onclick="toggleLazyLoading()">遅延読み込み切り替え</button>
                <button onclick="scrollToBottom()">下部にスクロール</button>
            </div>
            <div id="lazy-loading-results" class="stats-display"></div>
        </div>
        
        <div class="test-section">
            <h3>4. ローディング表示機能テスト</h3>
            <div class="controls">
                <button onclick="testLoadingIndicator()">ローディング表示テスト</button>
                <button onclick="testBatchLoadingIndicator()">バッチローディングテスト</button>
            </div>
            <div id="loading-indicator" class="loading-indicator">
                <div>処理中... <span id="loading-progress">0%</span></div>
            </div>
            <div id="loading-results" class="stats-display"></div>
        </div>
        
        <div class="test-section">
            <h3>5. パフォーマンス統計</h3>
            <div class="controls">
                <button onclick="showPerformanceStats()">統計表示</button>
                <button onclick="showOptimizationStatus()">最適化状態表示</button>
                <button onclick="resetStats()">統計リセット</button>
            </div>
            <div id="performance-stats" class="stats-display"></div>
        </div>
        
        <!-- テスト用要素 -->
        <div class="test-elements" id="test-elements">
            <!-- JavaScript で動的に生成 -->
        </div>
    </div>

    <!-- 必要なライブラリを読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="content/ad-preview-capture.js"></script>

    <script>
        let adPreviewCapture;
        let testElements = [];
        let performanceTestResults = [];

        // 初期化
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // AdPreviewCaptureインスタンスを作成
                adPreviewCapture = new AdPreviewCapture({
                    debugMode: true,
                    targetProcessingTime: 500,
                    memoryCleanupThreshold: 10 * 1024 * 1024, // 10MB (テスト用に低く設定)
                    lazyLoadingEnabled: true,
                    loadingIndicatorEnabled: true,
                    onLoadingStart: (captureId, element) => {
                        showLoadingIndicator(`要素 ${captureId} を処理中...`);
                    },
                    onLoadingEnd: (captureId, loadingTime) => {
                        hideLoadingIndicator();
                        updateLoadingResults(`要素 ${captureId} 処理完了 (${loadingTime}ms)`);
                    },
                    onBatchLoadingStart: (batchId, elementCount) => {
                        showLoadingIndicator(`バッチ処理中... (${elementCount}個の要素)`);
                    },
                    onBatchLoadingEnd: (batchId, loadingTime, elementCount) => {
                        hideLoadingIndicator();
                        updateLoadingResults(`バッチ処理完了: ${elementCount}個の要素を${loadingTime}msで処理`);
                    }
                });

                await adPreviewCapture.waitForInit();
                
                // テスト用要素を生成
                generateTestElements();
                
                // メモリ監視を開始
                startMemoryMonitoring();
                
                console.log('パフォーマンス最適化テスト環境が初期化されました');
                
            } catch (error) {
                console.error('初期化エラー:', error);
                alert('初期化に失敗しました: ' + error.message);
            }
        });

        // テスト用要素を生成
        function generateTestElements() {
            const container = document.getElementById('test-elements');
            container.innerHTML = '';
            testElements = [];

            // 様々なサイズの要素を生成
            for (let i = 0; i < 20; i++) {
                const element = document.createElement('div');
                element.className = 'test-element';
                
                if (i % 5 === 0) {
                    element.classList.add('large');
                } else if (i % 3 === 0) {
                    element.classList.add('small');
                }
                
                element.textContent = `テスト要素 ${i + 1}`;
                element.id = `test-element-${i}`;
                
                container.appendChild(element);
                testElements.push(element);
            }
        }

        // 1. 処理時間テスト
        async function testProcessingTime() {
            const startTime = Date.now();
            const resultsDiv = document.getElementById('processing-time-results');
            
            try {
                resultsDiv.innerHTML = '処理時間テスト実行中...';
                
                // 単一要素のキャプチャテスト
                const singleElement = testElements[0];
                const singleStartTime = Date.now();
                const singleResult = await adPreviewCapture.captureElement(singleElement);
                const singleTime = Date.now() - singleStartTime;
                
                // 複数要素のキャプチャテスト
                const multipleElements = testElements.slice(0, 5);
                const multipleStartTime = Date.now();
                const multipleResults = await adPreviewCapture.captureMultipleElements(multipleElements);
                const multipleTime = Date.now() - multipleStartTime;
                
                const totalTime = Date.now() - startTime;
                
                const results = {
                    singleElementTime: singleTime,
                    multipleElementsTime: multipleTime,
                    totalTime: totalTime,
                    target: 500,
                    singleWithinTarget: singleTime <= 500,
                    multipleWithinTarget: multipleTime <= 500,
                    totalWithinTarget: totalTime <= 500
                };
                
                displayProcessingTimeResults(results);
                performanceTestResults.push({
                    test: 'processing_time',
                    timestamp: Date.now(),
                    results: results
                });
                
            } catch (error) {
                resultsDiv.innerHTML = `エラー: ${error.message}`;
            }
        }

        function displayProcessingTimeResults(results) {
            const resultsDiv = document.getElementById('processing-time-results');
            const status = results.totalWithinTarget ? 'performance-good' : 'performance-warning';
            
            resultsDiv.innerHTML = `
                <div class="${status}">
                    <strong>処理時間テスト結果:</strong><br>
                    単一要素: ${results.singleElementTime}ms ${results.singleWithinTarget ? '✓' : '✗'}<br>
                    複数要素(5個): ${results.multipleElementsTime}ms ${results.multipleWithinTarget ? '✓' : '✗'}<br>
                    合計時間: ${results.totalTime}ms ${results.totalWithinTarget ? '✓' : '✗'}<br>
                    目標: ${results.target}ms以内
                </div>
            `;
        }

        // バッチ処理テスト
        async function testBatchProcessing() {
            const resultsDiv = document.getElementById('processing-time-results');
            
            try {
                resultsDiv.innerHTML = 'バッチ処理テスト実行中...';
                
                const batchSizes = [3, 5, 10, 15];
                const batchResults = [];
                
                for (const size of batchSizes) {
                    const elements = testElements.slice(0, size);
                    const startTime = Date.now();
                    
                    const results = await adPreviewCapture.captureMultipleElements(elements, {
                        showLoadingIndicator: true
                    });
                    
                    const processingTime = Date.now() - startTime;
                    const successCount = results.filter(r => r.screenshot && !r.fallback).length;
                    
                    batchResults.push({
                        size: size,
                        processingTime: processingTime,
                        successCount: successCount,
                        successRate: (successCount / size) * 100,
                        withinTarget: processingTime <= 500
                    });
                }
                
                displayBatchResults(batchResults);
                
            } catch (error) {
                resultsDiv.innerHTML = `バッチ処理エラー: ${error.message}`;
            }
        }

        function displayBatchResults(batchResults) {
            const resultsDiv = document.getElementById('processing-time-results');
            let html = '<div><strong>バッチ処理テスト結果:</strong><br>';
            
            batchResults.forEach(result => {
                const status = result.withinTarget ? '✓' : '✗';
                const statusClass = result.withinTarget ? 'color: green' : 'color: red';
                
                html += `
                    <div style="${statusClass}">
                        ${result.size}個: ${result.processingTime}ms 
                        (成功率: ${result.successRate.toFixed(1)}%) ${status}
                    </div>
                `;
            });
            
            html += '</div>';
            resultsDiv.innerHTML = html;
        }

        // 大量要素処理テスト
        async function testLargeElementProcessing() {
            const resultsDiv = document.getElementById('processing-time-results');
            
            try {
                resultsDiv.innerHTML = '大量要素処理テスト実行中...';
                
                // 全要素を処理
                const startTime = Date.now();
                const results = await adPreviewCapture.captureMultipleElements(testElements, {
                    showLoadingIndicator: true
                });
                const processingTime = Date.now() - startTime;
                
                const successCount = results.filter(r => r.screenshot && !r.fallback).length;
                const stats = adPreviewCapture.getPerformanceStats();
                
                resultsDiv.innerHTML = `
                    <div class="${processingTime <= 500 ? 'performance-good' : 'performance-warning'}">
                        <strong>大量要素処理結果:</strong><br>
                        要素数: ${testElements.length}個<br>
                        処理時間: ${processingTime}ms<br>
                        成功数: ${successCount}個<br>
                        成功率: ${((successCount / testElements.length) * 100).toFixed(1)}%<br>
                        平均処理時間: ${stats.averageProcessingTime.toFixed(1)}ms<br>
                        目標達成: ${processingTime <= 500 ? 'はい' : 'いいえ'}
                    </div>
                `;
                
            } catch (error) {
                resultsDiv.innerHTML = `大量要素処理エラー: ${error.message}`;
            }
        }

        // 2. メモリ監視テスト
        function startMemoryMonitoring() {
            setInterval(updateMemoryDisplay, 2000);
        }

        function updateMemoryDisplay() {
            if (!adPreviewCapture) return;
            
            const memoryInfo = adPreviewCapture.getMemoryInfo();
            const threshold = adPreviewCapture.options.memoryCleanupThreshold;
            const usagePercent = (memoryInfo.estimated / threshold) * 100;
            
            const memoryFill = document.getElementById('memory-fill');
            const memoryText = document.getElementById('memory-text');
            
            memoryFill.style.width = Math.min(100, usagePercent) + '%';
            memoryText.textContent = `${(memoryInfo.estimated / 1024 / 1024).toFixed(1)} MB`;
            
            if (usagePercent > 80) {
                memoryFill.style.background = '#f44336';
            } else if (usagePercent > 50) {
                memoryFill.style.background = '#ff9800';
            } else {
                memoryFill.style.background = '#4caf50';
            }
        }

        async function testMemoryMonitoring() {
            const resultsDiv = document.getElementById('memory-results');
            
            try {
                resultsDiv.innerHTML = 'メモリ監視テスト実行中...';
                
                // 大量のキャプチャを実行してメモリ使用量を増加
                for (let i = 0; i < 3; i++) {
                    await adPreviewCapture.captureMultipleElements(testElements);
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                const memoryInfo = adPreviewCapture.getMemoryInfo();
                const stats = adPreviewCapture.getPerformanceStats();
                
                resultsDiv.innerHTML = `
                    <div>
                        <strong>メモリ監視結果:</strong><br>
                        現在のメモリ使用量: ${(memoryInfo.estimated / 1024 / 1024).toFixed(1)} MB<br>
                        キャッシュサイズ: ${memoryInfo.cacheSize}個<br>
                        メモリ閾値: ${(adPreviewCapture.options.memoryCleanupThreshold / 1024 / 1024).toFixed(1)} MB<br>
                        ピーク使用量: ${(stats.memoryPeakUsage / 1024 / 1024).toFixed(1)} MB<br>
                        最終クリーンアップ: ${new Date(stats.lastCleanup).toLocaleTimeString()}
                    </div>
                `;
                
            } catch (error) {
                resultsDiv.innerHTML = `メモリ監視エラー: ${error.message}`;
            }
        }

        function triggerMemoryCleanup() {
            const resultsDiv = document.getElementById('memory-results');
            
            try {
                const beforeMemory = adPreviewCapture.getMemoryInfo();
                adPreviewCapture.performMemoryCleanup('manual');
                
                setTimeout(() => {
                    const afterMemory = adPreviewCapture.getMemoryInfo();
                    const freedMemory = beforeMemory.estimated - afterMemory.estimated;
                    
                    resultsDiv.innerHTML = `
                        <div class="performance-good">
                            <strong>手動クリーンアップ完了:</strong><br>
                            クリーンアップ前: ${(beforeMemory.estimated / 1024 / 1024).toFixed(1)} MB<br>
                            クリーンアップ後: ${(afterMemory.estimated / 1024 / 1024).toFixed(1)} MB<br>
                            解放されたメモリ: ${(freedMemory / 1024 / 1024).toFixed(1)} MB<br>
                            キャッシュサイズ: ${beforeMemory.cacheSize} → ${afterMemory.cacheSize}
                        </div>
                    `;
                }, 100);
                
            } catch (error) {
                resultsDiv.innerHTML = `クリーンアップエラー: ${error.message}`;
            }
        }

        async function simulateMemoryPressure() {
            const resultsDiv = document.getElementById('memory-results');
            
            try {
                resultsDiv.innerHTML = 'メモリ圧迫シミュレート中...';
                
                // 大量のキャプチャを実行
                const promises = [];
                for (let i = 0; i < 10; i++) {
                    promises.push(adPreviewCapture.captureMultipleElements(testElements.slice(0, 5)));
                }
                
                await Promise.all(promises);
                
                const memoryInfo = adPreviewCapture.getMemoryInfo();
                const threshold = adPreviewCapture.options.memoryCleanupThreshold;
                const usagePercent = (memoryInfo.estimated / threshold) * 100;
                
                resultsDiv.innerHTML = `
                    <div class="${usagePercent > 80 ? 'performance-warning' : 'performance-good'}">
                        <strong>メモリ圧迫シミュレート結果:</strong><br>
                        メモリ使用量: ${(memoryInfo.estimated / 1024 / 1024).toFixed(1)} MB<br>
                        使用率: ${usagePercent.toFixed(1)}%<br>
                        キャッシュサイズ: ${memoryInfo.cacheSize}個<br>
                        自動クリーンアップ: ${usagePercent > 80 ? '実行される予定' : '実行されません'}
                    </div>
                `;
                
            } catch (error) {
                resultsDiv.innerHTML = `メモリ圧迫シミュレートエラー: ${error.message}`;
            }
        }

        // 3. 遅延読み込みテスト
        async function testLazyLoading() {
            const resultsDiv = document.getElementById('lazy-loading-results');
            
            try {
                resultsDiv.innerHTML = '遅延読み込みテスト実行中...';
                
                // 画面外の要素を選択
                const offScreenElements = testElements.slice(10, 15);
                
                const startTime = Date.now();
                const results = await adPreviewCapture.captureMultipleElements(offScreenElements, {
                    enableLazyLoading: true
                });
                const processingTime = Date.now() - startTime;
                
                const lazyLoadCount = results.filter(r => r.isLazyLoad).length;
                const immediateLoadCount = results.length - lazyLoadCount;
                
                resultsDiv.innerHTML = `
                    <div class="performance-good">
                        <strong>遅延読み込みテスト結果:</strong><br>
                        処理時間: ${processingTime}ms<br>
                        即座に読み込み: ${immediateLoadCount}個<br>
                        遅延読み込み: ${lazyLoadCount}個<br>
                        遅延読み込み待ち: ${adPreviewCapture.lazyLoadManager.pendingLoads.size}個<br>
                        効果: ${lazyLoadCount > 0 ? '遅延読み込みが機能しています' : '全て即座に読み込まれました'}
                    </div>
                `;
                
            } catch (error) {
                resultsDiv.innerHTML = `遅延読み込みテストエラー: ${error.message}`;
            }
        }

        function toggleLazyLoading() {
            adPreviewCapture.options.lazyLoadingEnabled = !adPreviewCapture.options.lazyLoadingEnabled;
            
            const resultsDiv = document.getElementById('lazy-loading-results');
            resultsDiv.innerHTML = `
                <div>
                    遅延読み込み: ${adPreviewCapture.options.lazyLoadingEnabled ? '有効' : '無効'}
                </div>
            `;
        }

        function scrollToBottom() {
            window.scrollTo({
                top: document.body.scrollHeight,
                behavior: 'smooth'
            });
            
            setTimeout(() => {
                const resultsDiv = document.getElementById('lazy-loading-results');
                resultsDiv.innerHTML += `<div>下部にスクロールしました。遅延読み込み要素が読み込まれる可能性があります。</div>`;
            }, 1000);
        }

        // 4. ローディング表示テスト
        async function testLoadingIndicator() {
            try {
                showLoadingIndicator('単一要素ローディングテスト中...');
                
                const element = testElements[0];
                const result = await adPreviewCapture.captureElement(element, {
                    showLoadingIndicator: true
                });
                
                hideLoadingIndicator();
                updateLoadingResults('単一要素ローディングテスト完了');
                
            } catch (error) {
                hideLoadingIndicator();
                updateLoadingResults(`ローディングテストエラー: ${error.message}`);
            }
        }

        async function testBatchLoadingIndicator() {
            try {
                const elements = testElements.slice(0, 8);
                const results = await adPreviewCapture.captureMultipleElements(elements, {
                    showLoadingIndicator: true
                });
                
                updateLoadingResults(`バッチローディングテスト完了: ${results.length}個の要素を処理`);
                
            } catch (error) {
                updateLoadingResults(`バッチローディングテストエラー: ${error.message}`);
            }
        }

        function showLoadingIndicator(message) {
            const indicator = document.getElementById('loading-indicator');
            indicator.classList.add('active');
            indicator.querySelector('div').textContent = message;
        }

        function hideLoadingIndicator() {
            const indicator = document.getElementById('loading-indicator');
            indicator.classList.remove('active');
        }

        function updateLoadingResults(message) {
            const resultsDiv = document.getElementById('loading-results');
            const timestamp = new Date().toLocaleTimeString();
            resultsDiv.innerHTML += `<div>[${timestamp}] ${message}</div>`;
        }

        // 5. パフォーマンス統計表示
        function showPerformanceStats() {
            const stats = adPreviewCapture.getPerformanceStats();
            const resultsDiv = document.getElementById('performance-stats');
            
            resultsDiv.innerHTML = `
                <div>
                    <strong>パフォーマンス統計:</strong><br>
                    総キャプチャ数: ${stats.totalCaptures}<br>
                    成功数: ${stats.successfulCaptures}<br>
                    失敗数: ${stats.failedCaptures}<br>
                    成功率: ${stats.successRate.toFixed(1)}%<br>
                    平均処理時間: ${stats.averageProcessingTime.toFixed(1)}ms<br>
                    目標時間: ${stats.targetProcessingTime}ms<br>
                    目標達成: ${stats.isWithinTarget ? 'はい' : 'いいえ'}<br>
                    <br>
                    <strong>メモリ統計:</strong><br>
                    現在のメモリ使用量: ${(stats.currentMemoryUsage / 1024 / 1024).toFixed(1)} MB<br>
                    ピーク使用量: ${(stats.memoryPeakUsage / 1024 / 1024).toFixed(1)} MB<br>
                    <br>
                    <strong>キャッシュ統計:</strong><br>
                    キャッシュサイズ: ${stats.cacheSize}<br>
                    キャッシュヒット率: ${stats.cacheHitRate.toFixed(1)}%<br>
                    <br>
                    <strong>遅延読み込み:</strong><br>
                    有効: ${stats.lazyLoadEnabled ? 'はい' : 'いいえ'}<br>
                    待機中: ${stats.pendingLazyLoads}個<br>
                    読み込み中: ${stats.activeLoadings}個
                </div>
            `;
        }

        function showOptimizationStatus() {
            const status = adPreviewCapture.getOptimizationStatus();
            const resultsDiv = document.getElementById('performance-stats');
            
            let statusColor = 'performance-good';
            if (status.status === 'needs_optimization') {
                statusColor = 'performance-warning';
            }
            
            let html = `
                <div class="${statusColor}">
                    <strong>最適化状態: ${status.status}</strong><br>
                </div>
            `;
            
            if (status.recommendations.length > 0) {
                html += '<div><strong>推奨事項:</strong><br>';
                status.recommendations.forEach(rec => {
                    html += `• ${rec.message}<br>`;
                });
                html += '</div>';
            }
            
            resultsDiv.innerHTML = html;
        }

        function resetStats() {
            // 統計をリセット
            adPreviewCapture.performanceStats = {
                totalCaptures: 0,
                successfulCaptures: 0,
                failedCaptures: 0,
                averageProcessingTime: 0,
                memoryPeakUsage: 0,
                cacheHitRate: 0,
                optimizationEvents: []
            };
            
            adPreviewCapture.performanceMonitor = {
                processingTimes: [],
                memoryUsage: [],
                lastCleanup: Date.now(),
                isOptimizing: false
            };
            
            // キャッシュもクリア
            adPreviewCapture.clearCache();
            
            const resultsDiv = document.getElementById('performance-stats');
            resultsDiv.innerHTML = '<div class="performance-good">統計がリセットされました</div>';
        }
    </script>
</body>
</html>